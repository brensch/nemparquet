package util

import (
	"bufio"
	"context" // Keep context for potential future use (e.g., cancellation)
	"io"
	"strings"
)

// PeekableScanner wraps bufio.Scanner to allow peeking at the next line
// without consuming it from the underlying scanner. This is useful for
// looking ahead at record types in structured text files like NEM CSVs.
type PeekableScanner struct {
	scanner    *bufio.Scanner
	peekedLine *string         // Stores the line read by PeekRecordType
	peekErr    error           // Stores any error encountered during peeking
	context    context.Context // Context for potential cancellation (not actively used yet)
}

// NewPeekableScanner creates a new PeekableScanner wrapping the given io.Reader.
func NewPeekableScanner(r io.Reader) *PeekableScanner {
	scanner := bufio.NewScanner(r)
	// Default buffer size can be set here, but it's often overridden later
	// using the Buffer method based on expected line lengths.
	return &PeekableScanner{scanner: scanner, context: context.Background()}
}

// Scan advances the scanner to the next token (line).
// If a line was previously peeked, this consumes the peeked line first.
// Returns false when the scan stops, either by reaching the end of the input
// or an error. After Scan returns false, the Err method will return any error
// that occurred during scanning, except that if it was io.EOF, Err will return nil.
func (ps *PeekableScanner) Scan() bool {
	// Check context first (optional, for future cancellation integration)
	select {
	case <-ps.context.Done():
		ps.peekErr = ps.context.Err() // Store context error
		return false                  // Stop scanning
	default:
		// If a line was peeked, consume it now
		if ps.peekedLine != nil {
			ps.peekedLine = nil // Clear the peeked line
			ps.peekErr = nil    // Clear any previous peek error
			return true         // Indicate success (consumed peeked line)
		}
		// Otherwise, perform a normal scan using the underlying scanner
		return ps.scanner.Scan()
	}
}

// Text returns the most recent token generated by a call to Scan.
// It returns the current line being processed or the previously peeked line
// if Scan was just called after a PeekRecordType.
func (ps *PeekableScanner) Text() string {
	if ps.peekedLine != nil {
		// If we are consuming a peeked line, return its value
		return *ps.peekedLine
	}
	// Otherwise, return the text from the underlying scanner
	return ps.scanner.Text()
}

// Err returns the first non-EOF error that was encountered by the Scanner.
// It also returns any error encountered during peeking or context cancellation.
func (ps *PeekableScanner) Err() error {
	// Prioritize context or peek errors if they occurred
	if ps.peekErr != nil {
		return ps.peekErr
	}
	// Otherwise, return the underlying scanner's error
	return ps.scanner.Err()
}

// PeekRecordType reads ahead to find the next non-empty, non-comment line
// without consuming it from the main Scan sequence. It extracts and returns
// the record type (the first comma-separated value) from that line.
// Returns the record type string and any error encountered during the peek scan.
func (ps *PeekableScanner) PeekRecordType() (string, error) {
	// If a line is already peeked, return its type immediately
	if ps.peekedLine != nil {
		return ps.extractRecordType(*ps.peekedLine), ps.peekErr
	}

	// Loop to read ahead, skipping blank lines or potential comment lines
	for ps.scanner.Scan() {
		line := ps.scanner.Text()
		trimmedLine := strings.TrimSpace(line)

		// Skip blank lines and lines starting with common comment characters
		if trimmedLine == "" || strings.HasPrefix(trimmedLine, "#") || strings.HasPrefix(trimmedLine, "//") {
			continue // Read the next line
		}

		// Found a significant line, store it for peeking
		ps.peekedLine = &line
		ps.peekErr = nil // Clear any previous peek error
		// Extract and return the record type from this peeked line
		return ps.extractRecordType(line), nil
	}

	// If the loop finishes, it means scanner ended (EOF or error) without finding a suitable line
	ps.peekErr = ps.scanner.Err() // Capture the final scanner error (might be nil if just EOF)
	ps.peekedLine = nil           // Ensure no peeked line is stored
	return "", ps.peekErr         // Return empty type and the error/nil
}

// extractRecordType isolates the first comma-separated value from a line,
// trimming whitespace, to determine the record type.
func (ps *PeekableScanner) extractRecordType(line string) string {
	trimmedLine := strings.TrimSpace(line)
	if trimmedLine == "" {
		return "" // Empty line has no type
	}
	// Split only on the first comma
	parts := strings.SplitN(trimmedLine, ",", 2)
	if len(parts) > 0 {
		// Return the first part, trimmed of any extra whitespace
		return strings.TrimSpace(parts[0])
	}
	// Should not happen for a non-empty line, but return empty defensively
	return ""
}

// Buffer sets the initial buffer size and maximum buffer size for the underlying scanner.
// Call this after NewPeekableScanner if you need larger buffer capacity than the default.
func (ps *PeekableScanner) Buffer(buf []byte, max int) {
	ps.scanner.Buffer(buf, max)
}
